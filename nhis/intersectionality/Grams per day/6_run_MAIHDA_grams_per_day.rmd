---
title: "6_Run_MAIHDA_grams_per_day"
---

This script undertakes a multi-level analysis of individual heterogeneity and discriminatory accuracy (MAIHDA)to estimate average alcohol consumption per intersectional group of sex/age/race/SES

Setup
```{r, warning=FALSE}
# Load in data
transformed_drinkers <- readRDS("U:/SIMAH/SIMAH_workplace/nhis/intersectionality/cleaned_data/6_nhis_alc_clean_transformed_drinkers_log.RDS")

# Load necessary packages
library("R2MLwiN")
library(tidyr)
library(dplyr)

# Bias toward non-scientific notation
options(scipen=10)

# State file path for MLwiN
options(MLwiN_path="C:\\Program Files\\MLwiN v3.05")
```

Prep data
```{r}
# Generate intersectional groups
data_intersections_MAIHDA <- transformed_drinkers %>% 
  group_by(SEX, race_5_cats, education_3_cats, age_3_cats, decade) %>% 
  mutate(intersections = cur_group_id()) %>%
  group_by(intersections) %>%
  mutate(count=n())

# Add a column of the observed mean grams per day for each intersection
data_intersections_MAIHDA <- data_intersections_MAIHDA %>%
  group_by(intersections) %>%
  mutate(mean_observed_grams = mean(alc_daily_g_capped_200))

# Create a reference table of the intersectional groups - numbers and names
temp <- data_intersections_MAIHDA %>%
  mutate(sex = dplyr::recode(SEX, Male = "M", Female = "F"),
         race_5_cats = dplyr::recode(race_5_cats, 
                                     "Black/African American" = "Black", 
                                     "Hispanic, White" = "Hispanic"),
         education_3_cats = dplyr::recode(education_3_cats, 
                                          "high school or less" = "low edu.", 
                                          "some college" = "med. edu.", 
                                          "4+ years college" = "high edu."))

temp2 <- temp %>% 
  mutate(intersectional_names = as.character(paste(sex, age_3_cats, race_5_cats, education_3_cats, decade)))

MAIHDA_intersections_reference <- distinct(temp2, intersections, .keep_all = TRUE) %>% dplyr::select(intersections, intersectional_names)

# Prep data for use with R2mlwin package:
# Generate a constant
data_intersections_MAIHDA <- data_intersections_MAIHDA %>%
  mutate(cons=1)

# Sort by intersections
data_intersections_MAIHDA <- data_intersections_MAIHDA %>% arrange(intersections)
```

# Specify MAIHDA model formula
```{r}
# Null model
F1 <- capped_daily_grams_log ~ 1 + (1 | intersections) + (1 | NHISPID)

# Main-effects model
F2 <- capped_daily_grams_log ~ 1 + SEX + age_3_cats + race_5_cats + education_3_cats + decade + (1 | intersections) + (1 | NHISPID)
```


# Run MAIHDA with IGLS

Run the null two-level model and calculate the variance partition coefficient (VPC)
```{r}
VarCompModel <- runMLwiN(Formula = F1, 
                          data = data_intersections_MAIHDA,
                         estoptions = list(resi.store = TRUE))

# Calculate the VPC
print(VPC <- VarCompModel["RP"][["RP2_var_Intercept"]]/
        (VarCompModel["RP"][["RP1_var_Intercept"]] + VarCompModel["RP"][["RP2_var_Intercept"]]))
```

# View the residuals at each level (null model)
```{r}
# level 1 residuals
hist(VarCompModel@residual$lev_1_resi_est_Intercept)
qqnorm(VarCompModel@residual$lev_1_resi_est_Intercept)
qqline(VarCompModel@residual$lev_1_resi_est_Intercept, col = "steelblue", lwd = 2)

# level 2 residuals
hist(VarCompModel@residual$lev_2_resi_est_Intercept)
qqnorm(VarCompModel@residual$lev_2_resi_est_Intercept)
qqline(VarCompModel@residual$lev_2_resi_est_Intercept, col = "steelblue", lwd = 2)
```
Run the main-effects two-level model (storing residuals) and recalculate VPC
```{r}
VarCompResid <- runMLwiN(Formula = F2, 
                         data = data_intersections_MAIHDA,
                         estoptions = list(resi.store = TRUE))

# Re-calculate VPC:
print(VPC <- VarCompResid["RP"][["RP2_var_Intercept"]]/(VarCompResid["RP"][["RP1_var_Intercep"]] + VarCompResid["RP"][["RP2_var_Intercept"]]))

# Save the results
saveRDS(VarCompResid, "U:/SIMAH/SIMAH_workplace/nhis/intersectionality/cleaned_data/VarCompResidIGLS_log.RDS")
```

View the residuals at each level (full model)
```{r}
# level 1 residuals
hist(VarCompResid@residual$lev_1_resi_est_Intercept)
qqnorm(VarCompResid@residual$lev_1_resi_est_Intercept)
qqline(VarCompResid@residual$lev_1_resi_est_Intercept, col = "steelblue", lwd = 2)
plot(VarCompResid@residual$lev_1_resi_est_Intercept)
abline(h = 0, lty = 2, col = "red")

# level 2 residuals
hist(VarCompResid@residual$lev_2_resi_est_Intercept)
qqnorm(VarCompResid@residual$lev_2_resi_est_Intercept)
qqline(VarCompResid@residual$lev_2_resi_est_Intercept, col = "steelblue", lwd = 2)
plot(VarCompResid@residual$lev_2_resi_est_Intercept)
abline(h = 0, lty = 2, col = "red")
```

Extract model results
```{r}
# Read in run model
VarCompResid <- readRDS("U:/SIMAH/SIMAH_workplace/nhis/intersectionality/cleaned_data/VarCompResidIGLS_log.RDS")

# Estimate yhat (and SEs) using predict function
data_intersections_MAIHDA$yhat <- predict(VarCompResid) # the predicted expected value
data_intersections_MAIHDA$yhat_se <- predict(VarCompResid, se.fit=TRUE)$se.fit # the standard error of the predicted expected value

# Create table with results for just one intersection
processed_intersections_MAIHDA <- distinct(data_intersections_MAIHDA, intersections, .keep_all = TRUE)

# Extract residuals from the Mlwin output object
processed_intersections_MAIHDA$residuals <- VarCompResid@residual$lev_2_resi_est_Intercept 

# Extract the estimate of variance around the residuals, and take the sqrt of it to get the standard error around the residuals
processed_intersections_MAIHDA$residualsSE <- sqrt(VarCompResid@residual$lev_2_resi_var_Intercept) %>% sqrt() # standard error around residuals

# Estimate the overall mean combining additive effects (mean) and multiplicative effects (residuals)
processed_intersections_MAIHDA <- processed_intersections_MAIHDA %>% 
  mutate(estimate = sum(yhat, residuals))

# Estimate the total standard error by combining the error around the mean plus the error around the residuals:
processed_intersections_MAIHDA <- processed_intersections_MAIHDA %>% 
  mutate(SE =(sqrt((yhat_se*yhat_se)+(residualsSE*residualsSE)))/2)

# Saving subset results table
Results_table_IGLS <- processed_intersections_MAIHDA %>%
  dplyr::select(intersections, count, birth_year, YEAR, decade, AGE, SEX, race_5_cats, education_3_cats, age_3_cats, yhat, yhat_se, residuals, residualsSE, estimate, SE)

Results_table_IGLS <- inner_join(Results_table_IGLS, MAIHDA_intersections_reference, by = "intersections")

saveRDS(Results_table_IGLS, "U:/SIMAH/SIMAH_workplace/nhis/intersectionality/cleaned_data/MAIHDA_results_IGLS_log.RDS")

# Read in results table if already processed
Results_table_IGLS <- readRDS("U:/SIMAH/SIMAH_workplace/nhis/intersectionality/cleaned_data/MAIHDA_results_IGLS_log.RDS")
```

# MAIHDA with MCMC

Duplicate data for use with MCMC
```{r}
data_intersections_MAIHDA_MCMC <- data_intersections_MAIHDA
```

Multilevel model, null, MCMC
```{r}
# Run the null two-level model and calculate the variance partition coefficient (VPC)
VarCompModelMCMC <- runMLwiN(Formula = F1, 
                              data = data_intersections_MAIHDA_MCMC, 
                              estoptions = list(resi.store = TRUE, EstM = 1,
                             burnin = 5000,
                             iter = 50000))

print(VPC <- VarCompModelMCMC["RP"][["RP2_var_Intercept"]]/(VarCompModelMCMC["RP"][["RP1_var_Intercept"]] + VarCompModelMCMC["RP"][["RP2_var_Intercept"]]))

saveRDS(VarCompModelMCMC, "U:/SIMAH/SIMAH_workplace/nhis/intersectionality/cleaned_data/VarCompModelMCMC.RDS")

summary(VarCompModelMCMC@chains)
mcmc_trace(VarCompModelMCMC@chains)
autocorr(VarCompModelMCMC@chains)
```


Multilevel model, main effects, MCMC
```{r}
# Run the main-effects two-level model (storing residuals) and recalculate VPC
VarCompResidMCMC <- runMLwiN(Formula = F2, 
                             data = data_intersections_MAIHDA_MCMC, 
                             estoptions = list(resi.store = TRUE, EstM = 1,
                             burnin = 500,
                             iter = 5000))
# Default: burn in = 500, iterations = 5000, a thinning factor of 1, a random number seed of 1, 1 chain 

print(VPC <- VarCompResidMCMC["RP"][["RP2_var_Intercept"]]/
        (VarCompResidMCMC["RP"][["RP1_var_Intercept"]] + VarCompResidMCMC["RP"][["RP2_var_Intercept"]]))

saveRDS(VarCompResidMCMC, "U:/SIMAH/SIMAH_workplace/nhis/intersectionality/cleaned_data/VarCompResidMCMC_log.RDS")

summary(VarCompResidMCMC@chains[, "FP_Intercept"])
mcmc_trace(VarCompResidMCMC@chains)
autocorr(VarCompResidMCMC@chains)
```

# Extract model results
```{r}
# Read in run model
VarCompResidMCMC <- readRDS("U:/SIMAH/SIMAH_workplace/nhis/intersectionality/cleaned_data/VarCompResidMCMC_log.RDS")

# Estimate yhat (and SEs) using predict function
data_intersections_MAIHDA_MCMC$yhat <- predict(VarCompResidMCMC) # the predicted expected value
data_intersections_MAIHDA_MCMC$yhat_se <- predict(VarCompResidMCMC, se.fit=TRUE)$se.fit # the standard error of the predicted expected value

# Create table with results for just one intersection
processed_intersections_MAIHDA_MCMC <- distinct(data_intersections_MAIHDA_MCMC, intersections, .keep_all = TRUE)

# Extract residuals from the Mlwin output object
processed_intersections_MAIHDA_MCMC$residuals <- VarCompResidMCMC@residual$lev_2_resi_est_Intercept

# Extract the estimate of variance around the residuals, and take the sqrt of it to get the standard error around the residuals
processed_intersections_MAIHDA_MCMC$residualsSE <- sqrt(VarCompResidMCMC@residual$lev_2_resi_variance_Intercept) # standard error around residuals

# Estimate the overall mean combining additive effects (main effects) and multiplicative effects (residuals)
processed_intersections_MAIHDA_MCMC <- processed_intersections_MAIHDA_MCMC %>% 
  mutate(estimate = sum(yhat, residuals))

# Estimate the total standard error by combining the error around the mean plus the error around the residuals:
processed_intersections_MAIHDA_MCMC <- processed_intersections_MAIHDA_MCMC %>% 
  mutate(SE =(sqrt((yhat_se*yhat_se)+(residualsSE*residualsSE)))/2)

# Saving subset results table
Results_table_MCMC <- processed_intersections_MAIHDA_MCMC %>%
  dplyr::select(intersections, count, birth_year, YEAR, decade, AGE, SEX, race_5_cats, education_3_cats, age_3_cats, yhat, yhat_se, residuals, residualsSE, estimate, SE, mean_observed_grams)

Results_table_MCMC <- inner_join(Results_table_MCMC, MAIHDA_intersections_reference, by = "intersections")

saveRDS(Results_table_MCMC, "U:/SIMAH/SIMAH_workplace/nhis/intersectionality/cleaned_data/MAIHDA_results_MCMC_log.RDS")

# Read in data if already processed
Results_table_MCMC <- readRDS("U:/SIMAH/SIMAH_workplace/nhis/intersectionality/cleaned_data/MAIHDA_results_MCMC_log.RDS")
```

# Compare the results from MCMC and IGLS
```{r}
Results_table_IGLS %>% group_by(SEX) %>% summarise(min=min(estimate), max=max(estimate), exp_min = exp(min), exp_max= exp(max))

Results_table_MCMC %>% group_by(SEX) %>% summarise(min=min(estimate), max=max(estimate), exp_min = exp(min), exp_max= exp(max))
```
